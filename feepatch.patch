diff --git a/src/evm_parse.c b/src/evm_parse.c
index 76dbed1..fcd99d3 100644
--- a/src/evm_parse.c
+++ b/src/evm_parse.c
@@ -562,11 +562,15 @@ enum parse_rv parse_eip1559_rlp_txn(struct EVM_RLP_txn_state *const state, evm_p
             state->gasLimit = gasLimit;
             FINISH_ITEM_CHUNK();
 
-            // TODO: We don't currently support the C-chain gas limit of 100 million,
-            // which would have a fee larger than what fits in a word
-            // possible future improvement: using nanosdk to actually do the overflow-checked gas arithmetic
-            if(MAX(maxFeePerGasLength, baseFeePerGasLength) + gasLimitLength + 1 > 8)
-              REJECT("Fee too large");
+            // // TODO: We don't currently support the C-chain gas limit of 100 million,
+            // // which would have a fee larger than what fits in a word
+            // // possible future improvement: using nanosdk to actually do the overflow-checked gas arithmetic
+            // if(MAX(maxFeePerGasLength, baseFeePerGasLength) + gasLimitLength + 1 > 8)
+            //   REJECT("Fee too large");
+
+            uint64_t feeDummy = 0;
+            if(__builtin_mul_overflow_p(state->priorityFeePerGas + state->baseFeePerGas, state->gasLimit, feeDummy))
+              REJECT("Fee calculation would overflow");
 
 
             PARSE_ITEM(EVM_EIP1559_TXN_TO, _to_buffer);
@@ -625,8 +629,6 @@ enum parse_rv parse_eip1559_rlp_txn(struct EVM_RLP_txn_state *const state, evm_p
 
             PARSE_ITEM(EVM_EIP1559_TXN_DATA, _data);
 
-            checkDataFieldLengthFitsTransaction(state);
-
             // If we exhaust the apdu while parsing the length, there's nothing yet to hand to the subparser
             if(state->rlpItem_state.state < 2)
               return sub_rv;
@@ -674,7 +676,11 @@ enum parse_rv parse_eip1559_rlp_txn(struct EVM_RLP_txn_state *const state, evm_p
                 return PARSE_RV_PROMPT;
             }
 
-            SET_PROMPT_VALUE(entry->data.output_prompt.fee = ((state->priorityFeePerGas + state->baseFeePerGas) * state->gasLimit));
+            if (__builtin_mul_overflow(state->priorityFeePerGas + state->baseFeePerGas), state->gasLimit, *dummyFee)) {
+              REJECT("Fee calculation overflowed.");
+            }
+
+            SET_PROMPT_VALUE(entry->data.output_prompt.fee = dummyFee);
             if(state->hasData) {
               if(ADD_ACCUM_PROMPT("Maximum Fee", output_evm_fee_to_string))
                 return PARSE_RV_PROMPT;
